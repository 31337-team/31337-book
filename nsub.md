Внутренности проекта
====================

Взгляд с 10 000 метров
======================
NSubstitute выглядит очень привлекательно благодаря своему API: мы декларативно задаем, как должен себя
вести substitute (arrange) и точно также проверяем результат (assert). Например, если метод 
```int A()``` должен вернуть 123, автору теста достаточно написать

	// Arrange.
	substitute.A().Returns(123);

Однако, естественность использования обошлась повышенной сложностью в реализации framework: какой-то одной
точки входа в код NSubstitute, которая покрывает даже этот простой пример *нет*. В примере выше
вместо этого у нас будут: 
- ```substitute.A()``` - только, чтобы сказать, для *какого* метода будет задаваться возвращаемое значение
- extension method ```void Returns<T>(this T value, T returnThis, params T[] returnThese)``` на результате
  ```A()```, чтобы передать значение 123 (параметр ```returnThis```) для последующих вызовов ```substitute.A()```.
  
И это был только самый простой вариант ;) Но не будем пока вдаваться в более сложные сценарии. Вместо этого
хочется обратить внимание на другой факт: где-то просто обязана собираться информация о всех подробностях
целого утверждения по типу "метод A должен возвращать 123". Раз одной точки входа для этого нет, то и 
передать все разом в качестве параметров не выйдет. Отсюда назревает необдимость завести какой-нибудь контекст 
- объект, поддерживающий состояние между вызовами различных вспомогательных методов (в том числе и public API).
Общий контекст для NSubstitute - ```SubstitutionContext``` (и соответствующий ```ISubstitutionContext```).
В большинстве случаев к полезному объекту framework (на любой фазе: arrange, act или assert) можно дойти через 
объект контекста - ```SubstitutionContext.Current``` (шепотом: синглтон!!1111 ;) ).
В процессе создания целого утверждения контекст будет накапливать в том числе и промежуточную информацию (для какого
метода идет описание, какие аргументы будут давать match и т.д. -- todo перепроверить).

Итак, в нашем маленьком примерчике промелькнуло два существенно разных способа взаимодействия с NSubstitute:
1. ***Вызов метода объекта substitute.*** Благодаря Castle DynamicProxy мы можем выполнять произвольный код в этот момент (однако,
не каждый метод может быть перехвачен - об этом чуть позже). Вызов метода полезен при arrange теста, где он лишь
сигнализирует о том, для какого метода мы хотим задвать спецификацию. Также он просто необходим при act части -
ведь нам хочется, чтоб substitute делал при вызове методов ровно то, что при arrange фазе теста :)
2. ***Вызов extension method из ```SubstituteExtensions```.*** Через такие методы можно задать, какие именно значения
должен возвращать подмененный объект. Тот факт, что он вызывается на возвращаемом значении (как ```A().Returns(123)```)
лишь хитрость, чтобы написать вызов A() и Returns() как один statement. Кроме того, через вывод типа-параметра (generic
type parameter, в случае ```Returns<T>()``` - это ```T```), автоматически выбирается, какого типа должен быть value -
написать ```A().Returns("some string")``` для ```int A()``` не выйдет (для T будет выведен тип int). Эта 
небольшая хитрость работает почти везде, но с методами без возвращаемого значения (```void A()```) возникает проблема.
Специально для них используется немножко другой pattern: некоторые extension методы используют тип самого substitute
в подобном трюке, как ```Returns<T>()``` поступал для аргуметов. Например, методы assert фазы ```Recieved()``` и 
```NotRecieved()``` (которые нужны в любом случае, даже если у метода нет возвращаемого значния - потому что должна быть 
возможность проверить, вызывали метод или нет). Методы такого типа будут позволять упомянуть метод в одном statement,
но уже после их вызова. Это достигается за счет возвращаемоего значения того же типа-параметра T, который
будет типом substitute. Например, ```T Recieved<T>(this T substitute)``` можно использовать в assert statement 
вида ```substitute.Recieved().A()```. Такой подход уже универсально работает как для методов с возвращемым значением, так
и без него.

В первом приближении мы получаем, что arrange и assert делается за счет несколько ухищренного подхода с перехватом
методов substitute + вспомогательные extension методы (и там важен даже порядок, в котором они вызываются - другой
связи между "половинками" этого подхода нет). Что касается act - он более ожидаемый: выполняется запрограммированная
на arrange работа через все тот же перехват методов substitute. Далее мы постараемся углубиться в детали всех этих
операций.

Перехват вызова в substitute
============================

Перехват вызовов реализован на Castle DynamicProxy - ```CastleForwardingInterceptor``` единственный interceptor и 
он фактически является ширмой для двух более интересных типов внутри NSubstitute: CastleInvocationMapper и ICallRouter.
При перехвате вызова DynamicProxy передает всю полезную информацию о параметрах и других свойствах через IInvocation.
На основе данных из объекта реализующего IInvocation уже механизм NSubstitute делает свой "описатель" перехваченного 
вызова через CastleInvocationMapper.Map(). Так появляется объект, реализующий ICall (уже специфичный для NSubstitute),
и в процессе к нему привязывается спецификация аргументов (todo: уточнить - на какие типы должно срабатывать, какое
действие выполнить, когда этот аргумент дает match...). Теперь не хватает самого результата, который 
должен вернуть метод нашего substitute. Это значение, а также ..., мы получаем через ICallRouter.Route(). Итак,
если забыть про спецификации аргументов, то все самое интересное происходит под командыванием именно CallRouter.

<pre>
CastleForwardingInterceptor        CastleInvocationMapper        ICallRouter
            $                                |                        |
        Intercept()                          |                        |
            $                                |                        |
            --- invocation : IInvocation ----> Map()                  |
            |                                $                        |
            <-------- call : ICall -----------                        |
            $                                |                        |
            --------- call : ICall -------------------------------> Route()
            |                                |                        $
            <----- returnValue : object -------------------------------
            $                                |                        |
</pre>

CallRouter и ко.
================
